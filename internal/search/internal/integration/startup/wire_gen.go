// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package startup

import (
	"context"
	"sync"

	"github.com/ecodeclub/mq-api"
	"github.com/ecodeclub/webook/internal/cases"
	"github.com/ecodeclub/webook/internal/interactive"
	"github.com/ecodeclub/webook/internal/search"
	"github.com/ecodeclub/webook/internal/search/internal/event"
	"github.com/ecodeclub/webook/internal/search/internal/repository"
	"github.com/ecodeclub/webook/internal/search/internal/repository/dao"
	"github.com/ecodeclub/webook/internal/search/internal/service"
	"github.com/ecodeclub/webook/internal/search/internal/web"
	"github.com/ecodeclub/webook/internal/search/ioc"
	testioc "github.com/ecodeclub/webook/internal/test/ioc"
	"github.com/elastic/go-elasticsearch/v9"
	"github.com/google/wire"
)

// Injectors from wire.go:

func InitModule(es *elasticsearch.TypedClient, q mq.MQ, caModule *cases.Module, intrModule *interactive.Module) (*search.Module, error) {
	questionDAO := ioc.InitQuestionDAO(es)
	questionRepo := repository.NewQuestionRepo(questionDAO)
	questionSetDAO := ioc.InitQuestionSetDAO(es)
	questionSetRepo := repository.NewQuestionSetRepo(questionSetDAO)
	skillDAO := ioc.InitSkillDAO(es)
	skillRepo := repository.NewSKillRepo(skillDAO)
	caseDAO := ioc.InitCaseDAO(es)
	caseRepo := repository.NewCaseRepo(caseDAO)
	searchService := service.NewSearchSvc(questionRepo, questionSetRepo, skillRepo, caseRepo)
	syncService := InitSyncSvc(es)
	syncConsumer := initSyncConsumer(syncService, q)
	examineService := caModule.ExamineSvc
	serviceService := intrModule.Svc
	handler := web.NewHandler(searchService, examineService, serviceService)
	adminHandler := initAdminHandler(es)
	module := &search.Module{
		SearchSvc:    searchService,
		SyncSvc:      syncService,
		C:            syncConsumer,
		Hdl:          handler,
		AdminHandler: adminHandler,
	}
	return module, nil
}

func InitHandler(caModule *cases.Module, intrModule *interactive.Module) (*web.Handler, error) {
	typedClient := testioc.InitES()
	mqMQ := testioc.InitMQ()
	module, err := InitModule(typedClient, mqMQ, caModule, intrModule)
	if err != nil {
		return nil, err
	}
	handler := module.Hdl
	return handler, nil
}

func InitAdminHandler(caModule *cases.Module, intrModule *interactive.Module) (*web.AdminHandler, error) {
	typedClient := testioc.InitES()
	mqMQ := testioc.InitMQ()
	module, err := InitModule(typedClient, mqMQ, caModule, intrModule)
	if err != nil {
		return nil, err
	}
	adminHandler := module.AdminHandler
	return adminHandler, nil
}

// wire.go:

func initAdminHandler(es *elasticsearch.TypedClient) *web.AdminHandler {
	InitIndexOnce(es)
	caDAO := ioc.InitAdminCaseDAO(es)
	questionDAO := ioc.InitAdminQuestionDAO(es)
	questionSetDAO := ioc.InitAdminQuestionSetDAO(es)
	skillDAO := ioc.InitAdminSkillDAO(es)
	caRepo := repository.NewCaseRepo(caDAO)
	questionRepo := repository.NewQuestionRepo(questionDAO)
	questionSetRepo := repository.NewQuestionSetRepo(questionSetDAO)
	skillRepo := repository.NewSKillRepo(skillDAO)
	adminSvc := service.NewSearchSvc(questionRepo, questionSetRepo, skillRepo, caRepo)
	return web.NewAdminHandler(adminSvc)
}

// 初始化c端handler
var HandlerSet = wire.NewSet(ioc.InitCaseDAO, ioc.InitQuestionDAO, ioc.InitQuestionSetDAO, ioc.InitSkillDAO, repository.NewCaseRepo, repository.NewQuestionRepo, repository.NewQuestionSetRepo, repository.NewSKillRepo, service.NewSearchSvc, web.NewHandler)

// 初始化syncSvc
var SyncSvcSet = wire.NewSet(
	InitAnyRepo,
	InitSyncSvc,
)

func InitAnyRepo(es *elasticsearch.TypedClient) repository.AnyRepo {
	InitIndexOnce(es)
	anyDAO := dao.NewAnyEsDAO(es)
	anyRepo := repository.NewAnyRepo(anyDAO)
	return anyRepo
}

func InitSyncSvc(es *elasticsearch.TypedClient) service.SyncService {
	anyRepo := InitAnyRepo(es)
	return service.NewSyncSvc(anyRepo)
}

var daoOnce = sync.Once{}

func InitIndexOnce(es *elasticsearch.TypedClient) {
	daoOnce.Do(func() {
		err := dao.InitEsTest(es)
		if err != nil {
			panic(err)
		}
	})
}

func initSyncConsumer(svc service.SyncService, q mq.MQ) *event.SyncConsumer {
	c, err := event.NewSyncConsumer(svc, q)
	if err != nil {
		panic(err)
	}
	c.Start(context.Background())
	return c
}
