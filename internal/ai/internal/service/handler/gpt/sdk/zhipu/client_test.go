package zhipu

//func Test_Example(t *testing.T) {
//	c, err := NewClient("apikey", "knowageId")
//	require.NoError(t, err)
//	postResponse, err := c.ChatCompletion(context.Background(), zhipu.ChatCompletionMessage{
//		Role: "user",
//		Content: `现在你扮演一个技术面试官，你会专注于考察程序员的知识是否丰富。
//
//接下来我会提供给你一个面试问题和一个候选人的回答。
//
//你需要根据面试问题从知识库中找到该问题的答案，并且提取出来这个问题的答案的关键点，作为标准答案的关键点。
//
//你将按照 15K，25K 和 35K 来分别列出关键点。
//
//而后你要提取出来候选人回答的关键点。
//
//接着你会对比标准答案和候选人回答，进行评分。评分分成三级：15K、25K、35K。
//
//评分标准是：
//1. 如果候选人回答出来 15K 部分的所有关键点，那么评分至少是 15K；
//2. 在 1 的基础上，如果标准答案不存在 25K 部分的回答，那么候选人评分至少是 25K；如果候选人回答出来了 25K 部分的所有关键点，那么评分至少是 25K；
//3. 在 2 的基础上，如果标准答案不存在 25K 部分的回答，那么候选人评分至少是 35K；如果候选人回答出来了在 35K 部分的所有关键点，那么评分是 35K；
//
//你不需要输出任何你提取的关键点，而是只输出以下内容：
//1. 评分： 输出 15K、25K、35K 之一。
//2. 遗漏的关键点，按照 15K，25K 和 35K 分别列出来
//
//
//这是问题：
//Go 使用的三色标记法是如何运行的？
//
//这是回答：
//三色标记法的的原作原理还是比较简单的：
//
//1. 在初始状态，所有的对象都是白色；
//2. 逐一扫描这些对象，以及这些对象指向的对象。在扫描的时候，这个对象就是灰色；
//3. 把对象的所有的儿子都扫描完毕，这个对象就被标记为黑色
//4. 从实现上来说，这个过程很类似于树的广度优先遍历，或者有向图的遍历。`,
//	})
//	require.NoError(t, err)
//	v, err := json.Marshal(postResponse)
//	require.NoError(t, err)
//	log.Println(string(v))
//}
