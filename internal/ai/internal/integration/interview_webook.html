<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>ç¨‹åºå‘˜æ¨¡æ‹Ÿé¢è¯• Â· ç™¾ç‚¼ç‰ˆ (Assistant API + Paraformer-v2)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 24px; color: #1f2328; background: #f6f8fa; }
        h1 { margin-bottom: 8px; }
        .row { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start; }
        .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 16px; background: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        button { padding: 10px 14px; border-radius: 8px; border: 1px solid #d0d7de; background: #fff; cursor: pointer; font-size: 14px; transition: all 0.2s; }
        button:hover:not([disabled]) { background: #f3f4f6; }
        button.primary { background: #0ea5e9; color: #fff; border-color: #0ea5e9; }
        button.primary:hover:not([disabled]) { background: #0284c7; }
        button.destructive { background: #ef4444; color: #fff; border-color: #ef4444; }
        button.destructive:hover:not([disabled]) { background: #dc2626; }
        button[disabled] { opacity: .5; cursor: not-allowed; }
        .recording { background: #ef4444 !important; color: #fff !important; border-color: #ef4444 !important; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .muted { color: #6b7280; font-size: 13px; }
        pre { background: #0f172a; color: #e2e8f0; padding: 12px; border-radius: 8px; white-space: pre-wrap; font-size: 13px; line-height: 1.6; overflow-x: auto; }
        .score { display:flex; gap:12px; flex-wrap: wrap; margin-bottom: 12px; }
        .badge { padding: 6px 12px; background:#dbeafe; color:#1e40af; border-radius: 999px; font-size: 13px; font-weight: 500; }
        .highlight {
            background: #0f172a !important;
            border: 3px solid #10b981 !important;
            box-shadow: 0 0 0 4px rgba(16, 185, 129, 0.15);
        }
        .error { background: #fee2e2; border: 1px solid #fca5a5; color: #991b1b; padding: 12px; border-radius: 8px; margin-top: 8px; }
        .loading { color: #6b7280; font-style: italic; }
        .info { background: #dcfce7; border: 1px solid #16a34a; color: #166534; padding: 12px; border-radius: 8px; margin-bottom: 12px; font-weight: 500; }
        .meta { background: #f3f4f6; border: 1px solid #d1d5db; padding: 8px 12px; border-radius: 6px; font-size: 12px; margin-top: 8px; }
    </style>
    <script src="https://unpkg.com/cos-js-sdk-v5@1.10.1/dist/cos-js-sdk-v5.min.js"></script>
</head>
<body>

<div class="info">
    âœ… <strong>ç™¾ç‚¼ç‰ˆæœ¬ (Assistant API + Paraformer-v2) - webook é›†æˆç‰ˆ</strong>ï¼š
    ä½¿ç”¨ç™¾ç‚¼ <code>paraformer-v2</code> è½¬å†™éŸ³é¢‘ï¼ˆæ— éœ€ç”³è¯·ï¼Œç›´æ¥å¯ç”¨ï¼Œé€šè¿‡è…¾è®¯ COSï¼‰ï¼Œ
    ç„¶åé€šè¿‡ <code>webook</code> è½¬å‘åˆ° <code>ai-gateway-go</code> çš„ gRPC StreamV1 æ¥å£å¤„ç†é¢è¯•é€»è¾‘ï¼ˆç™¾ç‚¼ Assistant APIï¼‰ã€‚
    <br/>ğŸ“ ç«¯å£: 8080 (webook API)
</div>

<h1>ç¨‹åºå‘˜æ¨¡æ‹Ÿé¢è¯• Â· Webookç‰ˆ </h1>
<p class="muted">æµç¨‹ï¼šå¼€å§‹é¢è¯• â†’ æ’­æŠ¥é¢˜ç›® â†’ å½•éŸ³ â†’ paraformer-v2è½¬å†™ â†’ StreamV1è¯„åˆ† â†’ å¾ªç¯ â†’ ç»“æŸæ€»ç»“</p>

<div class="row">
    <div class="card">
        <h3>ğŸ“‹ å½“å‰é¢˜ç›® <span id="questionNum" class="muted"></span></h3>
        <div id="question" style="min-height:60px; font-size:18px; line-height:1.6; color:#1f2937;"></div>
        <div style="margin-top:12px; display:flex; gap:8px; flex-wrap: wrap;">
            <button id="btnStartInterview" class="primary">å¼€å§‹é¢è¯•</button>
            <button id="btnSpeak" disabled>ğŸ”Š æ’­æ”¾é¢˜ç›®</button>
            <button id="btnNext" disabled>ä¸‹ä¸€é¢˜ â†’</button>
            <button id="btnDontKnow" disabled>æˆ‘ä¸ä¼š â­ï¸</button>
        </div>
        <div id="convMeta" class="meta" style="display:none;"></div>
    </div>

    <div class="card">
        <h3>ğŸ¤ ä½ çš„å›ç­”ï¼ˆä»…è¯­éŸ³ï¼‰</h3>
        <div style="display:flex; gap:8px; flex-wrap: wrap;">
            <button id="btnRecord" disabled>å¼€å§‹è¯­éŸ³å½•åˆ¶</button>
            <button id="btnSubmit" disabled>æäº¤å¹¶è¯„ä¼°</button>
            <button id="btnEnd" class="destructive" disabled>ç»“æŸé¢è¯•</button>
        </div>
        <p id="recStatus" class="muted" style="margin-top:10px;">ç­‰å¾…å¼€å§‹...</p>
        <audio id="player" controls style="width:100%; margin-top:8px; display:none;"></audio>
    </div>
</div>

<div class="row" style="margin-top:20px;">
    <div class="card">
        <h3>éŸ³é¢‘URL</h3>
        <pre id="transcriptBox" class="loading">// ä¸Šä¼ OSSåæ˜¾ç¤ºå…¬ç½‘è®¿é—®éŸ³é¢‘URL</pre>
    </div>
    <div class="card">
        <h3>â­ å•é¢˜è¯„åˆ†ä¸ç‚¹è¯„ï¼ˆvia gRPC StreamV1ï¼‰</h3>
        <div id="scores" class="score"></div>
        <pre id="judgeBox" class="loading">// æäº¤åå°†å±•ç¤ºAIçš„è¯„åˆ†å’Œå»ºè®®</pre>
    </div>
</div>

<div class="card" style="margin-top:20px;" id="summaryCard">
    <h3>ğŸ“Š æ•´ä½“æ€»ç»“æŠ¥å‘Š</h3>
    <pre id="summaryBox" class="loading">// ç‚¹å‡»"ç»“æŸé¢è¯•"åç”Ÿæˆç»¼åˆè¯„ä»·</pre>
</div>

<script>
    // ========== é…ç½® ==========
    const INTERVIEW_API = 'http://localhost:8080';    // webook APIï¼ˆä¸ TestInterviewProxyServer ä¸å†²çªï¼Œä½¿ç”¨æ—¶éœ€å•ç‹¬å¯åŠ¨ï¼‰
    const INVOCATION_CONFIG_ID = 100001;              // InvocationConfig ID
    
    // ========== è…¾è®¯ COS é…ç½®ï¼ˆè¯·æ‰‹åŠ¨å¡«å†™ï¼‰==========
    const COS_BUCKET_NAME = 'webook-1314583317';      // å­˜å‚¨æ¡¶åç§°
    const COS_REGION = 'ap-nanjing';                   // åœ°åŸŸ

    // ========== å…¨å±€å˜é‡ ==========
    let mediaRecorder, chunks = [], recordStartTime = 0;
    let isRecording = false;
    let lastBlob = null;
    let askedQuestions = [];
    let history = [];
    let chatSn = null;                                // Chat SNï¼ˆæ›¿ä»£ conversation_idï¼‰
    let isInterviewStarted = false;
    let isLastQuestion = false;                       // æ ‡è®°æ˜¯å¦æœ€åä¸€é¢˜
    
    // ========== å»é‡çŠ¶æ€ ==========
    let seenQuestions = new Set();                    // é¢˜ç›®å»é‡ï¼šç”¨ question_id
    let seenEvaluations = new Set();                  // è¯„ä»·å»é‡ï¼šç”¨ question_id
    let summaryReceived = false;                      // æ€»ç»“å»é‡ï¼šåªæœ‰ä¸€ä¸ª

    // ========== DOM å…ƒç´  ==========
    const els = {
        question: document.getElementById('question'),
        questionNum: document.getElementById('questionNum'),
        btnStartInterview: document.getElementById('btnStartInterview'),
        btnSpeak: document.getElementById('btnSpeak'),
        btnNext: document.getElementById('btnNext'),
        btnDontKnow: document.getElementById('btnDontKnow'),
        btnRecord: document.getElementById('btnRecord'),
        btnSubmit: document.getElementById('btnSubmit'),
        btnEnd: document.getElementById('btnEnd'),
        recStatus: document.getElementById('recStatus'),
        player: document.getElementById('player'),
        transcriptBox: document.getElementById('transcriptBox'),
        judgeBox: document.getElementById('judgeBox'),
        scores: document.getElementById('scores'),
        summaryBox: document.getElementById('summaryBox'),
        summaryCard: document.getElementById('summaryCard'),
        convMeta: document.getElementById('convMeta')
    };

    // ========== å·¥å…·å‡½æ•° ==========
    function speak(text) {
        const u = new SpeechSynthesisUtterance(text);
        u.lang = 'zh-CN';
        speechSynthesis.speak(u);
    }

    function showError(element, message) {
        const div = document.createElement('div');
        div.className = 'error';
        div.textContent = `âŒ ${message}`;
        element.innerHTML = '';
        element.appendChild(div);
    }

    // ========== JSON å¤„ç†å‡½æ•° ==========
    function handleJSONResult(result) {
        if (!result || !result.type) {
            console.warn('âš ï¸ æ— æ•ˆçš„JSONç»“æœ:', result);
            return;
        }
        
        console.log('ğŸ” å¤„ç†JSONç±»å‹:', result.type);
        
        switch (result.type) {
            case 'question':
                // é¢˜ç›®å»é‡ï¼šç”¨ question_id
                if (seenQuestions.has(result.question_id)) {
                    console.log('â­ï¸ è·³è¿‡é‡å¤çš„é¢˜ç›®:', result.question_id);
                    return;
                }
                seenQuestions.add(result.question_id);
                displayQuestion(result);
                break;
            case 'evaluation':
                // è¯„ä»·å»é‡ï¼šç”¨ question_id
                if (seenEvaluations.has(result.question_id)) {
                    console.log('â­ï¸ è·³è¿‡é‡å¤çš„è¯„ä»·:', result.question_id);
                    return;
                }
                seenEvaluations.add(result.question_id);
                displayEvaluation(result);
                break;
            case 'summary':
                // æ€»ç»“å»é‡ï¼šåªæœ‰ä¸€ä¸ª
                if (summaryReceived) {
                    console.log('â­ï¸ è·³è¿‡é‡å¤çš„æ€»ç»“');
                    return;
                }
                summaryReceived = true;
                displaySummary(result);
                break;
            default:
                console.warn('â“ æœªçŸ¥ç±»å‹:', result.type);
        }
    }

    function displayQuestion(q) {
        els.question.textContent = q.question;
        // remaining_questions åŒ…å«å½“å‰é¢˜ï¼Œæ‰€ä»¥å®é™…å‰©ä½™ = remaining_questions - 1
        const actualRemaining = q.remaining_questions - 1;
        els.questionNum.textContent = `(ç¬¬ ${q.current} é¢˜ï¼Œå‰©ä½™ ${actualRemaining} é¢˜)`;
        
        // ğŸš¨ åˆ¤æ–­æ˜¯å¦æœ€åä¸€é¢˜
        // remaining_questions åŒ…å«å½“å‰é¢˜ï¼Œæ‰€ä»¥ remaining_questions === 1 æ‰æ˜¯æœ€åä¸€é¢˜
        if (q.remaining_questions === 1) {
            console.log('âš ï¸ è¿™æ˜¯æœ€åä¸€é¢˜');
            isLastQuestion = true;
        } else {
            isLastQuestion = false;
        }
        
        // å¯ç”¨æŒ‰é’®
        els.btnSpeak.disabled = false;
        els.btnRecord.disabled = false;
        els.btnEnd.disabled = false;
        els.btnDontKnow.disabled = false;
    }

    function displayEvaluation(e) {
        // æ¸²æŸ“è¯„åˆ†
        els.scores.innerHTML = '';
        ['content_score', 'coverage_score', 'structure_score'].forEach(k => {
            const score = e.scores[k];
            const div = document.createElement('div');
            div.className = 'badge';
            const label = k.replace('_score', '');
            div.textContent = `${label}: ${score}`;
            div.style.background = score >= 80 ? '#dcfce7' : score >= 60 ? '#fef3c7' : '#fee2e2';
            div.style.color = score >= 80 ? '#166534' : score >= 60 ? '#92400e' : '#991b1b';
            els.scores.appendChild(div);
        });
        
        // æ¸²æŸ“è¯„ä»·è¯¦æƒ…
        els.judgeBox.textContent = JSON.stringify(e.evaluation, null, 2);
        els.judgeBox.className = '';
        
        // å¯ç”¨ä¸‹ä¸€é¢˜æŒ‰é’®
        els.btnNext.disabled = false;
        
        // ğŸš¨ æ³¨æ„ï¼šä¸å†éœ€è¦è‡ªåŠ¨ç»“æŸé€»è¾‘ï¼Œå› ä¸ºç°åœ¨ç”±å‘½ä»¤é©±åŠ¨
        // å‰ç«¯ä¼šæ ¹æ® isLastQuestion çŠ¶æ€å‘é€æ­£ç¡®çš„å‘½ä»¤
    }

    function displaySummary(s) {
        els.summaryBox.textContent = JSON.stringify(s, null, 2);
        els.summaryBox.className = 'highlight';
        els.summaryCard.scrollIntoView({ behavior: 'smooth' });
        
        // é‡ç½®æŒ‰é’®çŠ¶æ€
        els.btnStartInterview.disabled = false;
        els.btnStartInterview.textContent = 'å¼€å§‹æ–°é¢è¯•';
    }

    // ========== é‡ç½®é¢è¯•çŠ¶æ€ ==========
    function resetInterview() {
        isRecording = false;
        lastBlob = null;
        askedQuestions = [];
        history = [];
        chatSn = null;
        isLastQuestion = false;
        
        // é‡ç½®å»é‡çŠ¶æ€
        seenQuestions.clear();
        seenEvaluations.clear();
        summaryReceived = false;

        els.question.textContent = '';
        els.questionNum.textContent = '';
        els.convMeta.style.display = 'none';
        els.btnSpeak.disabled = true;
        els.btnNext.disabled = true;
        els.btnDontKnow.disabled = true;
        els.btnRecord.disabled = true;
        els.btnSubmit.disabled = true;
        els.btnEnd.disabled = true;
        els.recStatus.textContent = 'ç­‰å¾…å¼€å§‹...';
        els.player.style.display = 'none';
        els.transcriptBox.textContent = '// æäº¤åè½¬å†™å¹¶æ˜¾ç¤º';
        els.transcriptBox.className = 'loading';
        els.judgeBox.textContent = '// æäº¤åå°†å±•ç¤ºAIçš„è¯„åˆ†å’Œå»ºè®®';
        els.judgeBox.className = 'loading';
        els.scores.innerHTML = '';
        els.summaryBox.textContent = '// ç‚¹å‡»"ç»“æŸé¢è¯•"åç”Ÿæˆç»¼åˆè¯„ä»·';
        els.summaryBox.className = 'loading';
        els.summaryBox.classList.remove('highlight');

        console.log('âœ… é¢è¯•çŠ¶æ€å·²é‡ç½®');
    }

    // ========== åˆ›å»º Chat ==========
    async function createChat() {
        try {
            const r = await fetch(`${INTERVIEW_API}/ai/mock_interview/create`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    title: "MySQL æ¨¡æ‹Ÿé¢è¯•"
                })
            });
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const data = await r.json();
            chatSn = data.data || data.chat_sn || data.sn;
            els.convMeta.textContent = `ğŸ“Œ Chat SN: ${chatSn}`;
            els.convMeta.style.display = 'block';
            console.log('âœ… åˆ›å»º Chat:', chatSn);
        } catch (e) {
            console.error('âŒ åˆ›å»º Chat å¤±è´¥:', e);
            alert('æ— æ³•åˆ›å»ºä¼šè¯ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨');
            throw e;
        }
    }

    // ========== æµå¼è¯·æ±‚ StreamV1 ==========
    async function streamRequest(audioUrl, content = null) {
        els.judgeBox.textContent = 'å¤„ç†ä¸­...';
        els.judgeBox.className = 'loading';
        els.scores.innerHTML = '';

        try {
            // æ„å»ºè¯·æ±‚ä½“
            const requestBody = {
                interviewId: chatSn,
                content: content || '',
                audioUrl: audioUrl || '',
                configId: INVOCATION_CONFIG_ID
            };

            const response = await fetch(`${INTERVIEW_API}/ai/mock_interview/stream`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            // SSE æµå¼è¯»å–
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let accumulated = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n\n');
                buffer = lines.pop();

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const json = JSON.parse(line.slice(6));
                            console.log('ğŸ“¨ æ”¶åˆ° SSE æ•°æ®:', json);

                            // æ³¨æ„ï¼šgRPC proto ç”Ÿæˆçš„å­—æ®µæ˜¯é¦–å­—æ¯å¤§å†™çš„
                            const event = json.Event || json.event;
                            
                            // å¤„ç† Delta äº‹ä»¶ï¼ˆforward_result å‘é€çš„ JSONï¼‰
                            if (event && event.Delta) {
                                accumulated += event.Delta.content;
                                
                                // å°è¯•è§£æå®Œæ•´çš„ JSON
                                try {
                                    const result = JSON.parse(accumulated);
                                    if (result && result.type) {
                                        console.log('âœ… æˆåŠŸè§£æJSON:', result.type);
                                        handleJSONResult(result);
                                        accumulated = ''; // æ¸…ç©ºå·²å¤„ç†çš„å†…å®¹
                                    }
                                } catch (e) {
                                    // JSON è¿˜æœªå®Œæ•´ï¼Œç»§ç»­ç´¯ç§¯
                                    console.log('â³ JSON æœªå®Œæ•´ï¼Œç»§ç»­ç´¯ç§¯...');
                                }
                            }

                            // å¤„ç† Error äº‹ä»¶
                            if (event && event.Error) {
                                console.error('âŒ æ”¶åˆ°é”™è¯¯äº‹ä»¶:', event.Error);
                                showError(els.judgeBox, event.Error.message);
                            }

                            // å¤„ç† Usage äº‹ä»¶
                            if (event && event.Usage) {
                                console.log('ğŸ“Š Token ä½¿ç”¨:', event.Usage);
                            }

                            // å¤„ç† StepUpdate äº‹ä»¶
                            if (event && event.StepUpdate) {
                                console.log('ğŸ“ æ­¥éª¤æ›´æ–°:', event.StepUpdate);
                            }
                        } catch (e) {
                            console.error('è§£æ SSE å¤±è´¥:', e, 'åŸå§‹æ•°æ®:', line);
                        }
                    }

                    if (line.startsWith('event: done')) {
                        console.log('âœ… Stream å®Œæˆ');
                    }

                    if (line.startsWith('event: error')) {
                        console.error('âŒ Stream é”™è¯¯ï¼Œå®Œæ•´è¡Œ:', line);
                    }
                }
            }

            els.judgeBox.className = '';

        } catch (e) {
            console.error('âŒ Stream è¯·æ±‚å¤±è´¥:', e);
            showError(els.judgeBox, 'è¯·æ±‚å¤±è´¥ï¼š' + e.message);
        }
    }

    // ========== å½•éŸ³æ§åˆ¶ ==========
    async function toggleRecord() {
        if (isRecording) {
            mediaRecorder.stop();
            isRecording = false;
            els.btnRecord.classList.remove('recording');
            els.btnRecord.textContent = 'å¼€å§‹è¯­éŸ³å½•åˆ¶';
            const duration = ((Date.now() - recordStartTime) / 1000).toFixed(1);
            els.recStatus.textContent = `å½•éŸ³å·²åœæ­¢ï¼ˆæ—¶é•¿ï¼š${duration}ç§’ï¼‰`;
            els.btnEnd.disabled = false;
            els.btnDontKnow.disabled = false;
        } else {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                chunks = [];
                recordStartTime = Date.now();
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });

                mediaRecorder.ondataavailable = e => chunks.push(e.data);
                mediaRecorder.onstop = () => {
                    const duration = (Date.now() - recordStartTime) / 1000;
                    if (duration < 0.5) {
                        els.recStatus.textContent = 'âŒ å½•éŸ³æ—¶é•¿è¿‡çŸ­ï¼ˆ<0.5ç§’ï¼‰ï¼Œè¯·é‡æ–°å½•åˆ¶';
                        els.btnSubmit.disabled = true;
                        return;
                    }
                    const blob = new Blob(chunks, { type: 'audio/webm' });
                    lastBlob = blob;
                    els.player.src = URL.createObjectURL(blob);
                    els.player.style.display = 'block';
                    els.btnSubmit.disabled = false;
                };

                mediaRecorder.start();
                isRecording = true;
                els.btnRecord.classList.add('recording');
                els.btnRecord.textContent = 'â¹ ç»“æŸè¯­éŸ³å½•åˆ¶';
                els.recStatus.textContent = 'ğŸ”´ å½•éŸ³ä¸­...';
                els.btnEnd.disabled = true;
                els.btnNext.disabled = true;
                els.btnDontKnow.disabled = true;
                els.btnSubmit.disabled = true;
                els.player.style.display = 'none';
            } catch (e) {
                els.recStatus.textContent = 'âŒ æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™';
                console.error('âŒ å½•éŸ³å¤±è´¥:', e);
            }
        }
    }

    // ========== è·å– COS ä¸´æ—¶å¯†é’¥ ==========
    async function getTempCredentials() {
        const resp = await fetch(`${INTERVIEW_API}/ai/mock_interview/cos/temp-credentials`, {
            method: 'GET'
        });

        if (!resp.ok) {
            const errorText = await resp.text();
            console.error('âŒ è·å–ä¸´æ—¶å¯†é’¥å¤±è´¥:', errorText);
            throw new Error(`è·å–ä¸´æ—¶å¯†é’¥å¤±è´¥: HTTP ${resp.status}`);
        }

        return await resp.json();
    }

    // ========== åˆå§‹åŒ– COS å®ä¾‹ ==========
    async function initCOS() {
        const credentials = await getTempCredentials();
        
        const cosInstance = new COS({
            getAuthorization: function (options, callback) {
                callback({
                    TmpSecretId: credentials.tmpSecretId,
                    TmpSecretKey: credentials.tmpSecretKey,
                    SecurityToken: credentials.sessionToken,
                    StartTime: credentials.startTime,
                    ExpiredTime: credentials.expiredTime,
                });
            }
        });
        
        return { cos: cosInstance, credentials };
    }

    // ========== ä¸Šä¼ éŸ³é¢‘åˆ°è…¾è®¯ COS ==========
    async function uploadToCOS(blob) {
        console.log('ğŸ”‘ åˆå§‹åŒ– COS...');
        const { cos, credentials } = await initCOS();
        
        // ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
        const timestamp = Date.now();
        const key = `audio-temp/${timestamp}_audio.webm`;
        
        console.log('ğŸ“¤ ä¸Šä¼ éŸ³é¢‘åˆ° COS...', key);
        
        // ä½¿ç”¨ COS SDK ä¸Šä¼ 
        return new Promise((resolve, reject) => {
            cos.putObject({
                Bucket: credentials.bucket,
                Region: credentials.region,
                Key: key,
                Body: blob,
                onProgress: function (progressData) {
                    const percent = Math.round(progressData.percent * 100);
                    console.log(`ä¸Šä¼ è¿›åº¦: ${percent}%`);
                }
            }, function (err, data) {
                if (err) {
                    console.error('âŒ ä¸Šä¼ å¤±è´¥:', err);
                    reject(err);
                } else {
                    const fileURL = `https://${credentials.bucket}.cos.${credentials.region}.myqcloud.com/${key}`;
                    console.log('âœ… ä¸Šä¼ æˆåŠŸ:', fileURL);
                    resolve(fileURL);
                }
            });
        });
    }

    // ========== ä¸Šä¼ éŸ³é¢‘å¹¶è¿”å› URL ==========
    async function transcribeAudio(blob) {
        const cosUrl = await uploadToCOS(blob);
        return cosUrl;
    }

    // ========== UI é‡ç½® ==========
    function resetUIForNextQuestion() {
        els.player.style.display = 'none';
        els.transcriptBox.textContent = '// æäº¤åè½¬å†™å¹¶æ˜¾ç¤º';
        els.transcriptBox.className = 'loading';
        els.judgeBox.textContent = '// æäº¤åå°†å±•ç¤ºAIçš„è¯„åˆ†å’Œå»ºè®®';
        els.judgeBox.className = 'loading';
        els.scores.innerHTML = '';
        els.btnSubmit.disabled = true;
        els.btnNext.disabled = true;
        els.btnRecord.disabled = false;
        els.btnDontKnow.disabled = false;
        els.recStatus.textContent = 'æœªå½•éŸ³';
        lastBlob = null;
    }

    // ========== äº‹ä»¶ç»‘å®š ==========
    els.btnStartInterview.onclick = async () => {
        // å¦‚æœå·²ç»é¢è¯•è¿‡ï¼Œå…ˆé‡ç½®çŠ¶æ€
        if (isInterviewStarted) {
            resetInterview();
        }

        els.btnStartInterview.disabled = true;
        els.btnStartInterview.textContent = 'é¢è¯•ä¸­...';

        await createChat();

        // è¯·æ±‚ç¬¬ä¸€é¢˜ï¼ˆé¢˜ç›®ç¼–å·ç”±åç«¯çš„currentå­—æ®µæ§åˆ¶ï¼‰
        await streamRequest(null, "å¼€å§‹é¢è¯•");

        els.btnSpeak.disabled = false;
        els.btnSpeak.onclick = () => speak(els.question.textContent);
        els.btnRecord.disabled = false;
        els.btnEnd.disabled = false;
        els.btnDontKnow.disabled = false;
        els.recStatus.textContent = 'å°±ç»ªï¼Œå¯ä»¥å¼€å§‹å½•éŸ³';

        isInterviewStarted = true;
    };

    els.btnRecord.onclick = async () => {
        els.btnRecord.disabled = true;
        await toggleRecord();
        els.btnRecord.disabled = false;
    };

    els.btnSubmit.onclick = async () => {
        if (!lastBlob) {
            alert('è¯·å…ˆå½•éŸ³');
            return;
        }
        els.btnSubmit.disabled = true;
        els.btnRecord.disabled = true;

        // 1. ä¸Šä¼ éŸ³é¢‘åˆ° COSï¼Œè·å– URL
        els.transcriptBox.textContent = 'ğŸ“¤ ä¸Šä¼ éŸ³é¢‘åˆ° COS...';
        els.transcriptBox.className = 'loading';

        try {
            const audioUrl = await transcribeAudio(lastBlob);
            els.transcriptBox.textContent = `âœ… éŸ³é¢‘å·²ä¸Šä¼ : ${audioUrl}`;
            els.transcriptBox.className = '';

            // 2. æ ¹æ®æ˜¯å¦æ˜¯æœ€åä¸€é¢˜ï¼Œå‘é€ä¸åŒçš„å‘½ä»¤
            const q = els.question.textContent.trim();
            console.log('ğŸ“ å‘é€éŸ³é¢‘URL:', audioUrl);
            
            // å…ˆå‘é€è¯„ä»·å‘½ä»¤ï¼ˆç¬¬ä¸€æ­¥ï¼‰
            console.log('ğŸ“ å‘½ä»¤: è¯„ä»·ç­”æ¡ˆ');
            await streamRequest(audioUrl, "è¯„ä»·ç­”æ¡ˆ");
            
            // è¯„ä»·å®Œæˆåï¼Œæ ¹æ®æ˜¯å¦æœ€åä¸€é¢˜å†³å®šä¸‹ä¸€æ­¥
            if (isLastQuestion) {
                // æœ€åä¸€é¢˜ï¼šç”Ÿæˆé¢è¯•æ€»ç»“
                console.log('ğŸ“ å‘½ä»¤: ç”Ÿæˆé¢è¯•æ€»ç»“');
                await streamRequest(null, "ç”Ÿæˆé¢è¯•æ€»ç»“");
            } else {
                // éæœ€åä¸€é¢˜ï¼šè·å–ä¸‹ä¸€é¢˜
                console.log('ğŸ“ å‘½ä»¤: è·å–ä¸‹ä¸€é¢˜');
                await streamRequest(null, "è·å–ä¸‹ä¸€é¢˜");
            }

            // 3. ä¿å­˜å†å²
            history.push({ question: q, audioUrl });

        } catch (e) {
            showError(els.transcriptBox, 'ä¸Šä¼ å¤±è´¥ï¼š' + e.message);
            console.error(e);
        }

        els.btnSubmit.disabled = false;
        els.btnRecord.disabled = false;
    };

    els.btnNext.onclick = async () => {
        // ç¦ç”¨æŒ‰é’®é˜²æ­¢é‡å¤ç‚¹å‡»
        els.btnNext.disabled = true;
        
        // å‘é€"è·å–ä¸‹ä¸€é¢˜"å‘½ä»¤
        console.log('ğŸ“ å‘½ä»¤: è·å–ä¸‹ä¸€é¢˜');
        await streamRequest(null, "è·å–ä¸‹ä¸€é¢˜");
        
        // é‡ç½®UI
        resetUIForNextQuestion();
    };

    els.btnDontKnow.onclick = async () => {
        const q = els.question.textContent.trim();
        
        console.log('â­ï¸ è·³è¿‡é¢˜ç›®');
        
        // 1. å…ˆè¯„ä»·ï¼ˆç”¨æˆ·å›ç­”"æˆ‘ä¸ä¼š"ï¼‰
        console.log('ğŸ“ å‘½ä»¤: è¯„ä»·ç­”æ¡ˆ');
        await streamRequest(null, "è¯„ä»·ç­”æ¡ˆ\næˆ‘ä¸ä¼š");
        
        // 2. æ ¹æ®æ˜¯å¦æœ€åä¸€é¢˜å†³å®šä¸‹ä¸€æ­¥
        if (isLastQuestion) {
            console.log('ğŸ“ å‘½ä»¤: ç”Ÿæˆé¢è¯•æ€»ç»“');
            await streamRequest(null, "ç”Ÿæˆé¢è¯•æ€»ç»“");
        } else {
            console.log('ğŸ“ å‘½ä»¤: è·å–ä¸‹ä¸€é¢˜');
            await streamRequest(null, "è·å–ä¸‹ä¸€é¢˜");
        }
        
        history.push({ question: q, transcript: 'æˆ‘ä¸ä¼š', judge: { note: 'è·³è¿‡' } });
        resetUIForNextQuestion();
    };

    els.btnEnd.onclick = async () => {
        if (history.length === 0 && !isLastQuestion) {
            alert('æ‚¨è¿˜æ²¡æœ‰å›ç­”ä»»ä½•é—®é¢˜ï¼Œç¡®å®šè¦ç»“æŸå—ï¼Ÿ');
            return;
        }
        els.btnEnd.disabled = true;
        els.btnEnd.textContent = 'ç”Ÿæˆä¸­...';
        els.summaryBox.classList.add('highlight');
        els.summaryBox.textContent = 'æ­£åœ¨ç”Ÿæˆç»¼åˆæŠ¥å‘Š...';
        els.summaryBox.className = 'loading highlight';

        try {
            // ğŸš¨ å‘é€"ç»“æŸé¢è¯•"å‘½ä»¤
            console.log('ğŸ“ å‘é€å‘½ä»¤: ç»“æŸé¢è¯•');
            await streamRequest(null, "ç»“æŸé¢è¯•");

        } catch (e) {
            console.error('âŒ æ€»ç»“å¤±è´¥:', e);
            showError(els.summaryBox, 'ç”Ÿæˆæ€»ç»“å¤±è´¥ï¼Œè¯·é‡è¯•');
        }

        els.btnEnd.textContent = 'ç»“æŸé¢è¯•';
        els.btnEnd.disabled = false;
    };
</script>
</body>
</html>

