<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>程序员模拟面试 · 百炼版 (Assistant API + Paraformer-v2)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 24px; color: #1f2328; background: #f6f8fa; }
        h1 { margin-bottom: 8px; }
        .row { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start; }
        .card { border: 1px solid #e5e7eb; border-radius: 12px; padding: 16px; background: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }
        button { padding: 10px 14px; border-radius: 8px; border: 1px solid #d0d7de; background: #fff; cursor: pointer; font-size: 14px; transition: all 0.2s; }
        button:hover:not([disabled]) { background: #f3f4f6; }
        button.primary { background: #0ea5e9; color: #fff; border-color: #0ea5e9; }
        button.primary:hover:not([disabled]) { background: #0284c7; }
        button.destructive { background: #ef4444; color: #fff; border-color: #ef4444; }
        button.destructive:hover:not([disabled]) { background: #dc2626; }
        button[disabled] { opacity: .5; cursor: not-allowed; }
        .recording { background: #ef4444 !important; color: #fff !important; border-color: #ef4444 !important; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .muted { color: #6b7280; font-size: 13px; }
        pre { background: #0f172a; color: #e2e8f0; padding: 12px; border-radius: 8px; white-space: pre-wrap; font-size: 13px; line-height: 1.6; overflow-x: auto; }
        .score { display:flex; gap:12px; flex-wrap: wrap; margin-bottom: 12px; }
        .badge { padding: 6px 12px; background:#dbeafe; color:#1e40af; border-radius: 999px; font-size: 13px; font-weight: 500; }
        .highlight {
            background: #0f172a !important;
            border: 3px solid #10b981 !important;
            box-shadow: 0 0 0 4px rgba(16, 185, 129, 0.15);
        }
        .error { background: #fee2e2; border: 1px solid #fca5a5; color: #991b1b; padding: 12px; border-radius: 8px; margin-top: 8px; }
        .loading { color: #6b7280; font-style: italic; }
        .info { background: #dcfce7; border: 1px solid #16a34a; color: #166534; padding: 12px; border-radius: 8px; margin-bottom: 12px; font-weight: 500; }
        .meta { background: #f3f4f6; border: 1px solid #d1d5db; padding: 8px 12px; border-radius: 6px; font-size: 12px; margin-top: 8px; }
    </style>
    <script src="https://unpkg.com/cos-js-sdk-v5@1.10.1/dist/cos-js-sdk-v5.min.js"></script>
</head>
<body>

<div class="info">
    ✅ <strong>百炼版本 (Assistant API + Paraformer-v2) - webook 集成版</strong>：
    使用百炼 <code>paraformer-v2</code> 转写音频（无需申请，直接可用，通过腾讯 COS），
    然后通过 <code>webook</code> 转发到 <code>ai-gateway-go</code> 的 gRPC StreamV1 接口处理面试逻辑（百炼 Assistant API）。
    <br/>📍 端口: 8080 (webook API)
</div>

<h1>程序员模拟面试 · Webook版 </h1>
<p class="muted">流程：开始面试 → 播报题目 → 录音 → paraformer-v2转写 → StreamV1评分 → 循环 → 结束总结</p>

<div class="row">
    <div class="card">
        <h3>📋 当前题目 <span id="questionNum" class="muted"></span></h3>
        <div id="question" style="min-height:60px; font-size:18px; line-height:1.6; color:#1f2937;"></div>
        <div style="margin-top:12px; display:flex; gap:8px; flex-wrap: wrap;">
            <button id="btnStartInterview" class="primary">开始面试</button>
            <button id="btnSpeak" disabled>🔊 播放题目</button>
            <button id="btnNext" disabled>下一题 →</button>
            <button id="btnDontKnow" disabled>我不会 ⏭️</button>
        </div>
        <div id="convMeta" class="meta" style="display:none;"></div>
    </div>

    <div class="card">
        <h3>🎤 你的回答（仅语音）</h3>
        <div style="display:flex; gap:8px; flex-wrap: wrap;">
            <button id="btnRecord" disabled>开始语音录制</button>
            <button id="btnSubmit" disabled>提交并评估</button>
            <button id="btnEnd" class="destructive" disabled>结束面试</button>
        </div>
        <p id="recStatus" class="muted" style="margin-top:10px;">等待开始...</p>
        <audio id="player" controls style="width:100%; margin-top:8px; display:none;"></audio>
    </div>
</div>

<div class="row" style="margin-top:20px;">
    <div class="card">
        <h3>音频URL</h3>
        <pre id="transcriptBox" class="loading">// 上传OSS后显示公网访问音频URL</pre>
    </div>
    <div class="card">
        <h3>⭐ 单题评分与点评（via gRPC StreamV1）</h3>
        <div id="scores" class="score"></div>
        <pre id="judgeBox" class="loading">// 提交后将展示AI的评分和建议</pre>
    </div>
</div>

<div class="card" style="margin-top:20px;" id="summaryCard">
    <h3>📊 整体总结报告</h3>
    <pre id="summaryBox" class="loading">// 点击"结束面试"后生成综合评价</pre>
</div>

<script>
    // ========== 配置 ==========
    const INTERVIEW_API = 'http://localhost:8080';    // webook API（与 TestInterviewProxyServer 不冲突，使用时需单独启动）
    const INVOCATION_CONFIG_ID = 100001;              // InvocationConfig ID
    
    // ========== 腾讯 COS 配置（请手动填写）==========
    const COS_BUCKET_NAME = 'webook-1314583317';      // 存储桶名称
    const COS_REGION = 'ap-nanjing';                   // 地域

    // ========== 全局变量 ==========
    let mediaRecorder, chunks = [], recordStartTime = 0;
    let isRecording = false;
    let lastBlob = null;
    let askedQuestions = [];
    let history = [];
    let chatSn = null;                                // Chat SN（替代 conversation_id）
    let isInterviewStarted = false;
    let isLastQuestion = false;                       // 标记是否最后一题
    
    // ========== 去重状态 ==========
    let seenQuestions = new Set();                    // 题目去重：用 question_id
    let seenEvaluations = new Set();                  // 评价去重：用 question_id
    let summaryReceived = false;                      // 总结去重：只有一个

    // ========== DOM 元素 ==========
    const els = {
        question: document.getElementById('question'),
        questionNum: document.getElementById('questionNum'),
        btnStartInterview: document.getElementById('btnStartInterview'),
        btnSpeak: document.getElementById('btnSpeak'),
        btnNext: document.getElementById('btnNext'),
        btnDontKnow: document.getElementById('btnDontKnow'),
        btnRecord: document.getElementById('btnRecord'),
        btnSubmit: document.getElementById('btnSubmit'),
        btnEnd: document.getElementById('btnEnd'),
        recStatus: document.getElementById('recStatus'),
        player: document.getElementById('player'),
        transcriptBox: document.getElementById('transcriptBox'),
        judgeBox: document.getElementById('judgeBox'),
        scores: document.getElementById('scores'),
        summaryBox: document.getElementById('summaryBox'),
        summaryCard: document.getElementById('summaryCard'),
        convMeta: document.getElementById('convMeta')
    };

    // ========== 工具函数 ==========
    function speak(text) {
        const u = new SpeechSynthesisUtterance(text);
        u.lang = 'zh-CN';
        speechSynthesis.speak(u);
    }

    function showError(element, message) {
        const div = document.createElement('div');
        div.className = 'error';
        div.textContent = `❌ ${message}`;
        element.innerHTML = '';
        element.appendChild(div);
    }

    // ========== JSON 处理函数 ==========
    function handleJSONResult(result) {
        if (!result || !result.type) {
            console.warn('⚠️ 无效的JSON结果:', result);
            return;
        }
        
        console.log('🔍 处理JSON类型:', result.type);
        
        switch (result.type) {
            case 'question':
                // 题目去重：用 question_id
                if (seenQuestions.has(result.question_id)) {
                    console.log('⏭️ 跳过重复的题目:', result.question_id);
                    return;
                }
                seenQuestions.add(result.question_id);
                displayQuestion(result);
                break;
            case 'evaluation':
                // 评价去重：用 question_id
                if (seenEvaluations.has(result.question_id)) {
                    console.log('⏭️ 跳过重复的评价:', result.question_id);
                    return;
                }
                seenEvaluations.add(result.question_id);
                displayEvaluation(result);
                break;
            case 'summary':
                // 总结去重：只有一个
                if (summaryReceived) {
                    console.log('⏭️ 跳过重复的总结');
                    return;
                }
                summaryReceived = true;
                displaySummary(result);
                break;
            default:
                console.warn('❓ 未知类型:', result.type);
        }
    }

    function displayQuestion(q) {
        els.question.textContent = q.question;
        // remaining_questions 包含当前题，所以实际剩余 = remaining_questions - 1
        const actualRemaining = q.remaining_questions - 1;
        els.questionNum.textContent = `(第 ${q.current} 题，剩余 ${actualRemaining} 题)`;
        
        // 🚨 判断是否最后一题
        // remaining_questions 包含当前题，所以 remaining_questions === 1 才是最后一题
        if (q.remaining_questions === 1) {
            console.log('⚠️ 这是最后一题');
            isLastQuestion = true;
        } else {
            isLastQuestion = false;
        }
        
        // 启用按钮
        els.btnSpeak.disabled = false;
        els.btnRecord.disabled = false;
        els.btnEnd.disabled = false;
        els.btnDontKnow.disabled = false;
    }

    function displayEvaluation(e) {
        // 渲染评分
        els.scores.innerHTML = '';
        ['content_score', 'coverage_score', 'structure_score'].forEach(k => {
            const score = e.scores[k];
            const div = document.createElement('div');
            div.className = 'badge';
            const label = k.replace('_score', '');
            div.textContent = `${label}: ${score}`;
            div.style.background = score >= 80 ? '#dcfce7' : score >= 60 ? '#fef3c7' : '#fee2e2';
            div.style.color = score >= 80 ? '#166534' : score >= 60 ? '#92400e' : '#991b1b';
            els.scores.appendChild(div);
        });
        
        // 渲染评价详情
        els.judgeBox.textContent = JSON.stringify(e.evaluation, null, 2);
        els.judgeBox.className = '';
        
        // 启用下一题按钮
        els.btnNext.disabled = false;
        
        // 🚨 注意：不再需要自动结束逻辑，因为现在由命令驱动
        // 前端会根据 isLastQuestion 状态发送正确的命令
    }

    function displaySummary(s) {
        els.summaryBox.textContent = JSON.stringify(s, null, 2);
        els.summaryBox.className = 'highlight';
        els.summaryCard.scrollIntoView({ behavior: 'smooth' });
        
        // 重置按钮状态
        els.btnStartInterview.disabled = false;
        els.btnStartInterview.textContent = '开始新面试';
    }

    // ========== 重置面试状态 ==========
    function resetInterview() {
        isRecording = false;
        lastBlob = null;
        askedQuestions = [];
        history = [];
        chatSn = null;
        isLastQuestion = false;
        
        // 重置去重状态
        seenQuestions.clear();
        seenEvaluations.clear();
        summaryReceived = false;

        els.question.textContent = '';
        els.questionNum.textContent = '';
        els.convMeta.style.display = 'none';
        els.btnSpeak.disabled = true;
        els.btnNext.disabled = true;
        els.btnDontKnow.disabled = true;
        els.btnRecord.disabled = true;
        els.btnSubmit.disabled = true;
        els.btnEnd.disabled = true;
        els.recStatus.textContent = '等待开始...';
        els.player.style.display = 'none';
        els.transcriptBox.textContent = '// 提交后转写并显示';
        els.transcriptBox.className = 'loading';
        els.judgeBox.textContent = '// 提交后将展示AI的评分和建议';
        els.judgeBox.className = 'loading';
        els.scores.innerHTML = '';
        els.summaryBox.textContent = '// 点击"结束面试"后生成综合评价';
        els.summaryBox.className = 'loading';
        els.summaryBox.classList.remove('highlight');

        console.log('✅ 面试状态已重置');
    }

    // ========== 创建 Chat ==========
    async function createChat() {
        try {
            const r = await fetch(`${INTERVIEW_API}/ai/mock_interview/create`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    title: "MySQL 模拟面试"
                })
            });
            if (!r.ok) throw new Error(`HTTP ${r.status}`);
            const data = await r.json();
            chatSn = data.data || data.chat_sn || data.sn;
            els.convMeta.textContent = `📌 Chat SN: ${chatSn}`;
            els.convMeta.style.display = 'block';
            console.log('✅ 创建 Chat:', chatSn);
        } catch (e) {
            console.error('❌ 创建 Chat 失败:', e);
            alert('无法创建会话，请检查服务器');
            throw e;
        }
    }

    // ========== 流式请求 StreamV1 ==========
    async function streamRequest(audioUrl, content = null) {
        els.judgeBox.textContent = '处理中...';
        els.judgeBox.className = 'loading';
        els.scores.innerHTML = '';

        try {
            // 构建请求体
            const requestBody = {
                interviewId: chatSn,
                content: content || '',
                audioUrl: audioUrl || '',
                configId: INVOCATION_CONFIG_ID
            };

            const response = await fetch(`${INTERVIEW_API}/ai/mock_interview/stream`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            // SSE 流式读取
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let accumulated = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n\n');
                buffer = lines.pop();

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const json = JSON.parse(line.slice(6));
                            console.log('📨 收到 SSE 数据:', json);

                            // 注意：gRPC proto 生成的字段是首字母大写的
                            const event = json.Event || json.event;
                            
                            // 处理 Delta 事件（forward_result 发送的 JSON）
                            if (event && event.Delta) {
                                accumulated += event.Delta.content;
                                
                                // 尝试解析完整的 JSON
                                try {
                                    const result = JSON.parse(accumulated);
                                    if (result && result.type) {
                                        console.log('✅ 成功解析JSON:', result.type);
                                        handleJSONResult(result);
                                        accumulated = ''; // 清空已处理的内容
                                    }
                                } catch (e) {
                                    // JSON 还未完整，继续累积
                                    console.log('⏳ JSON 未完整，继续累积...');
                                }
                            }

                            // 处理 Error 事件
                            if (event && event.Error) {
                                console.error('❌ 收到错误事件:', event.Error);
                                showError(els.judgeBox, event.Error.message);
                            }

                            // 处理 Usage 事件
                            if (event && event.Usage) {
                                console.log('📊 Token 使用:', event.Usage);
                            }

                            // 处理 StepUpdate 事件
                            if (event && event.StepUpdate) {
                                console.log('📝 步骤更新:', event.StepUpdate);
                            }
                        } catch (e) {
                            console.error('解析 SSE 失败:', e, '原始数据:', line);
                        }
                    }

                    if (line.startsWith('event: done')) {
                        console.log('✅ Stream 完成');
                    }

                    if (line.startsWith('event: error')) {
                        console.error('❌ Stream 错误，完整行:', line);
                    }
                }
            }

            els.judgeBox.className = '';

        } catch (e) {
            console.error('❌ Stream 请求失败:', e);
            showError(els.judgeBox, '请求失败：' + e.message);
        }
    }

    // ========== 录音控制 ==========
    async function toggleRecord() {
        if (isRecording) {
            mediaRecorder.stop();
            isRecording = false;
            els.btnRecord.classList.remove('recording');
            els.btnRecord.textContent = '开始语音录制';
            const duration = ((Date.now() - recordStartTime) / 1000).toFixed(1);
            els.recStatus.textContent = `录音已停止（时长：${duration}秒）`;
            els.btnEnd.disabled = false;
            els.btnDontKnow.disabled = false;
        } else {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                chunks = [];
                recordStartTime = Date.now();
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });

                mediaRecorder.ondataavailable = e => chunks.push(e.data);
                mediaRecorder.onstop = () => {
                    const duration = (Date.now() - recordStartTime) / 1000;
                    if (duration < 0.5) {
                        els.recStatus.textContent = '❌ 录音时长过短（<0.5秒），请重新录制';
                        els.btnSubmit.disabled = true;
                        return;
                    }
                    const blob = new Blob(chunks, { type: 'audio/webm' });
                    lastBlob = blob;
                    els.player.src = URL.createObjectURL(blob);
                    els.player.style.display = 'block';
                    els.btnSubmit.disabled = false;
                };

                mediaRecorder.start();
                isRecording = true;
                els.btnRecord.classList.add('recording');
                els.btnRecord.textContent = '⏹ 结束语音录制';
                els.recStatus.textContent = '🔴 录音中...';
                els.btnEnd.disabled = true;
                els.btnNext.disabled = true;
                els.btnDontKnow.disabled = true;
                els.btnSubmit.disabled = true;
                els.player.style.display = 'none';
            } catch (e) {
                els.recStatus.textContent = '❌ 无法访问麦克风，请检查浏览器权限';
                console.error('❌ 录音失败:', e);
            }
        }
    }

    // ========== 获取 COS 临时密钥 ==========
    async function getTempCredentials() {
        const resp = await fetch(`${INTERVIEW_API}/ai/mock_interview/cos/temp-credentials`, {
            method: 'GET'
        });

        if (!resp.ok) {
            const errorText = await resp.text();
            console.error('❌ 获取临时密钥失败:', errorText);
            throw new Error(`获取临时密钥失败: HTTP ${resp.status}`);
        }

        return await resp.json();
    }

    // ========== 初始化 COS 实例 ==========
    async function initCOS() {
        const credentials = await getTempCredentials();
        
        const cosInstance = new COS({
            getAuthorization: function (options, callback) {
                callback({
                    TmpSecretId: credentials.tmpSecretId,
                    TmpSecretKey: credentials.tmpSecretKey,
                    SecurityToken: credentials.sessionToken,
                    StartTime: credentials.startTime,
                    ExpiredTime: credentials.expiredTime,
                });
            }
        });
        
        return { cos: cosInstance, credentials };
    }

    // ========== 上传音频到腾讯 COS ==========
    async function uploadToCOS(blob) {
        console.log('🔑 初始化 COS...');
        const { cos, credentials } = await initCOS();
        
        // 生成唯一文件名
        const timestamp = Date.now();
        const key = `audio-temp/${timestamp}_audio.webm`;
        
        console.log('📤 上传音频到 COS...', key);
        
        // 使用 COS SDK 上传
        return new Promise((resolve, reject) => {
            cos.putObject({
                Bucket: credentials.bucket,
                Region: credentials.region,
                Key: key,
                Body: blob,
                onProgress: function (progressData) {
                    const percent = Math.round(progressData.percent * 100);
                    console.log(`上传进度: ${percent}%`);
                }
            }, function (err, data) {
                if (err) {
                    console.error('❌ 上传失败:', err);
                    reject(err);
                } else {
                    const fileURL = `https://${credentials.bucket}.cos.${credentials.region}.myqcloud.com/${key}`;
                    console.log('✅ 上传成功:', fileURL);
                    resolve(fileURL);
                }
            });
        });
    }

    // ========== 上传音频并返回 URL ==========
    async function transcribeAudio(blob) {
        const cosUrl = await uploadToCOS(blob);
        return cosUrl;
    }

    // ========== UI 重置 ==========
    function resetUIForNextQuestion() {
        els.player.style.display = 'none';
        els.transcriptBox.textContent = '// 提交后转写并显示';
        els.transcriptBox.className = 'loading';
        els.judgeBox.textContent = '// 提交后将展示AI的评分和建议';
        els.judgeBox.className = 'loading';
        els.scores.innerHTML = '';
        els.btnSubmit.disabled = true;
        els.btnNext.disabled = true;
        els.btnRecord.disabled = false;
        els.btnDontKnow.disabled = false;
        els.recStatus.textContent = '未录音';
        lastBlob = null;
    }

    // ========== 事件绑定 ==========
    els.btnStartInterview.onclick = async () => {
        // 如果已经面试过，先重置状态
        if (isInterviewStarted) {
            resetInterview();
        }

        els.btnStartInterview.disabled = true;
        els.btnStartInterview.textContent = '面试中...';

        await createChat();

        // 请求第一题（题目编号由后端的current字段控制）
        await streamRequest(null, "开始面试");

        els.btnSpeak.disabled = false;
        els.btnSpeak.onclick = () => speak(els.question.textContent);
        els.btnRecord.disabled = false;
        els.btnEnd.disabled = false;
        els.btnDontKnow.disabled = false;
        els.recStatus.textContent = '就绪，可以开始录音';

        isInterviewStarted = true;
    };

    els.btnRecord.onclick = async () => {
        els.btnRecord.disabled = true;
        await toggleRecord();
        els.btnRecord.disabled = false;
    };

    els.btnSubmit.onclick = async () => {
        if (!lastBlob) {
            alert('请先录音');
            return;
        }
        els.btnSubmit.disabled = true;
        els.btnRecord.disabled = true;

        // 1. 上传音频到 COS，获取 URL
        els.transcriptBox.textContent = '📤 上传音频到 COS...';
        els.transcriptBox.className = 'loading';

        try {
            const audioUrl = await transcribeAudio(lastBlob);
            els.transcriptBox.textContent = `✅ 音频已上传: ${audioUrl}`;
            els.transcriptBox.className = '';

            // 2. 根据是否是最后一题，发送不同的命令
            const q = els.question.textContent.trim();
            console.log('📝 发送音频URL:', audioUrl);
            
            // 先发送评价命令（第一步）
            console.log('📝 命令: 评价答案');
            await streamRequest(audioUrl, "评价答案");
            
            // 评价完成后，根据是否最后一题决定下一步
            if (isLastQuestion) {
                // 最后一题：生成面试总结
                console.log('📝 命令: 生成面试总结');
                await streamRequest(null, "生成面试总结");
            } else {
                // 非最后一题：获取下一题
                console.log('📝 命令: 获取下一题');
                await streamRequest(null, "获取下一题");
            }

            // 3. 保存历史
            history.push({ question: q, audioUrl });

        } catch (e) {
            showError(els.transcriptBox, '上传失败：' + e.message);
            console.error(e);
        }

        els.btnSubmit.disabled = false;
        els.btnRecord.disabled = false;
    };

    els.btnNext.onclick = async () => {
        // 禁用按钮防止重复点击
        els.btnNext.disabled = true;
        
        // 发送"获取下一题"命令
        console.log('📝 命令: 获取下一题');
        await streamRequest(null, "获取下一题");
        
        // 重置UI
        resetUIForNextQuestion();
    };

    els.btnDontKnow.onclick = async () => {
        const q = els.question.textContent.trim();
        
        console.log('⏭️ 跳过题目');
        
        // 1. 先评价（用户回答"我不会"）
        console.log('📝 命令: 评价答案');
        await streamRequest(null, "评价答案\n我不会");
        
        // 2. 根据是否最后一题决定下一步
        if (isLastQuestion) {
            console.log('📝 命令: 生成面试总结');
            await streamRequest(null, "生成面试总结");
        } else {
            console.log('📝 命令: 获取下一题');
            await streamRequest(null, "获取下一题");
        }
        
        history.push({ question: q, transcript: '我不会', judge: { note: '跳过' } });
        resetUIForNextQuestion();
    };

    els.btnEnd.onclick = async () => {
        if (history.length === 0 && !isLastQuestion) {
            alert('您还没有回答任何问题，确定要结束吗？');
            return;
        }
        els.btnEnd.disabled = true;
        els.btnEnd.textContent = '生成中...';
        els.summaryBox.classList.add('highlight');
        els.summaryBox.textContent = '正在生成综合报告...';
        els.summaryBox.className = 'loading highlight';

        try {
            // 🚨 发送"结束面试"命令
            console.log('📝 发送命令: 结束面试');
            await streamRequest(null, "结束面试");

        } catch (e) {
            console.error('❌ 总结失败:', e);
            showError(els.summaryBox, '生成总结失败，请重试');
        }

        els.btnEnd.textContent = '结束面试';
        els.btnEnd.disabled = false;
    };
</script>
</body>
</html>

